# SPDX-FileCopyrightText: Copyright (c) 2025 Broadsage Corporation <containers@broadsage.com>
#
# SPDX-License-Identifier: Apache-2.0
#
# This workflow detects changes to workflow files and creates releases with version documentation.
# 
# Features:
# - Automatic semantic versioning based on commit messages
# - Consolidated git setup and checkout patterns for performance  
# - Robust Python-based version replacement preventing corruption
# - Minimal dependencies and optimized job execution
# - Comprehensive error handling and validation

---
name: "Release Workflows"

on:
  push:
    branches: [main]
    paths:
      - '.github/workflows/*.yml'
      - '!.github/workflows/workflow-release.yml'
      - '!.github/workflows/version-docs.yml'
  pull_request:
    branches: [main]
    paths:
      - '.github/workflows/*.yml'
      - '!.github/workflows/workflow-release.yml'
      - '!.github/workflows/version-docs.yml'
    types: [closed]

# Global environment for consistency
env:
  GIT_USER_NAME: "github-actions[bot]"
  GIT_USER_EMAIL: "41898282+github-actions[bot]@users.noreply.github.com"

permissions:
  contents: read

jobs:
  # Detect workflow changes and determine version bump in single job for efficiency
  analyze-changes:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    outputs:
      has-changes: ${{ steps.detect.outputs.has-changes }}
      changed-workflows: ${{ steps.detect.outputs.workflows }}
      version-bump: ${{ steps.version.outputs.bump-type }}
      is-dependency-update: ${{ steps.version.outputs.is-dependency-update }}
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 100 # Optimized - only need recent history for version determination
          
      - name: Setup git configuration
        run: |
          git config --global user.name "${{ env.GIT_USER_NAME }}"
          git config --global user.email "${{ env.GIT_USER_EMAIL }}"

      - name: Detect workflow changes
        id: detect
        run: |
          echo "🔍 Detecting changes in workflow files..."
          
          # Get changed files in .github/workflows/ directory
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For merged PRs, compare against base branch
            base_sha="${{ github.event.pull_request.base.sha }}"
            head_sha="${{ github.event.pull_request.head.sha }}"
            changed_files=$(git diff --name-only "$base_sha" "$head_sha" -- .github/workflows/ | grep '\.yml$' || echo "")
          else
            # For direct pushes, compare with previous commit
            changed_files=$(git diff --name-only HEAD~1 HEAD -- .github/workflows/ | grep '\.yml$' || echo "")
          fi
          
          if [[ -z "$changed_files" ]]; then
            echo "No workflow changes detected"
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed workflow files: $changed_files"
          
          # Extract workflow names efficiently with single loop
          workflows=$(echo "$changed_files" | sed 's|.github/workflows/||g' | sed 's|\.yml$||g' | paste -sd ',')
          
          echo "Changed workflows: $workflows"
          echo "workflows=$workflows" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT

      - name: Determine version bump and dependency status  
        id: version
        run: |
          commit_message="${{ github.event.head_commit.message }}"
          actor="${{ github.actor }}"
          
          echo "Analyzing commit: $commit_message"
          echo "Actor: $actor"
          
          # Check dependency update status
          if [[ "$actor" == "dependabot[bot]" ]] || 
             [[ "$commit_message" =~ ^deps(\(.*\))?: ]]; then
            echo "is-dependency-update=true" >> $GITHUB_OUTPUT
            echo "🔧 Dependency update detected"
          else
            echo "is-dependency-update=false" >> $GITHUB_OUTPUT
          fi
          
          # Determine version bump type with optimized regex matching
          if [[ "$commit_message" =~ BREAKING.CHANGE ]] || 
             [[ "$commit_message" =~ ^[^:]*!: ]] ||
             [[ "$commit_message" =~ ^(feat|fix)!: ]]; then
            bump_type="major"
            echo "🚨 BREAKING CHANGE detected - major version bump"
          elif [[ "$commit_message" =~ ^(feat|add)(\(.*\))?: ]]; then
            bump_type="minor"
            echo "✨ Feature detected - minor version bump"  
          else
            bump_type="patch"
            echo "🐛 Patch change detected - patch version bump"
          fi
          
          echo "bump-type=$bump_type" >> $GITHUB_OUTPUT

  # Create release with optimized version calculation
  create-release:
    needs: analyze-changes
    if: needs.analyze-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      new-version: ${{ steps.release.outputs.new-version }}
      major-version: ${{ steps.release.outputs.major-version }}
    permissions:
      contents: write # Required for creating tags and releases
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # Full history required for version calculation
          
      - name: Setup git configuration  
        run: |
          git config --global user.name "${{ env.GIT_USER_NAME }}"
          git config --global user.email "${{ env.GIT_USER_EMAIL }}"

      - name: Calculate version and create release
        id: release
        run: |
          bump_type="${{ needs.analyze-changes.outputs.version-bump }}"
          workflows="${{ needs.analyze-changes.outputs.changed-workflows }}"
          
          # Get latest semantic version with improved sorting
          latest_tag=$(git tag -l "v*.*.*" | sort -V | tail -n1 || echo "v0.0.0")
          echo "Current latest: $latest_tag"
          
          # Parse current version with error handling
          if [[ "$latest_tag" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]} 
            patch=${BASH_REMATCH[3]}
          else
            echo "Invalid or missing version, starting from v0.0.0"
            major=0; minor=0; patch=0
          fi
          
          # Calculate new version using arithmetic expansion for performance
          case $bump_type in
            "major") new_major=$((major + 1)); new_minor=0; new_patch=0 ;;
            "minor") new_major=$major; new_minor=$((minor + 1)); new_patch=0 ;;
            "patch") new_major=$major; new_minor=$minor; new_patch=$((patch + 1)) ;;
          esac
          
          new_version="v$new_major.$new_minor.$new_patch"
          major_version="v$new_major"
          
          echo "New version: $new_version"
          echo "Major version: $major_version"
          
          # Validate version doesn't exist
          if git rev-parse --verify "$new_version" >/dev/null 2>&1; then
            echo "❌ Version $new_version already exists!"
            exit 1
          fi
          
          # Generate optimized release notes
          cat > release_notes.md << EOF
          ## What's Changed
          
          Updated workflows: **$workflows**
          
          EOF
          
          # Get key commits since last release (limited for performance)
          if [[ "$latest_tag" != "v0.0.0" ]]; then
            git log --oneline --format="* [%h](https://github.com/broadsage-containers/docker-ops/commit/%H) %s" \
              "$latest_tag"..HEAD -- .github/workflows/ | \
              grep -v -E "^[*] [a-f0-9]+ (chore|docs|style|refactor|test):" | \
              head -5 >> release_notes.md || echo "* Minor improvements and bug fixes" >> release_notes.md
          else
            echo "* Initial workflow release" >> release_notes.md
          fi
          
          cat >> release_notes.md << EOF
          
          ## Usage
          
          \`\`\`yaml
          uses: broadsage-containers/docker-ops/.github/workflows/{workflow}.yml@$new_version
          \`\`\`
          
          [Full Changelog](https://github.com/broadsage-containers/docker-ops/compare/$latest_tag...$new_version)
          EOF
          
          # Create tags atomically
          echo "🏷️ Creating tags..."
          git tag -a "$new_version" -m "Release $new_version - workflow updates"
          git tag -f -a "$major_version" -m "Major version $major_version (latest: $new_version)"
          
          # Push tags
          git push origin "$new_version"
          git push --force origin "$major_version"
          
          echo "new-version=$new_version" >> $GITHUB_OUTPUT
          echo "major-version=$major_version" >> $GITHUB_OUTPUT
          
          # Create GitHub release
          gh release create "$new_version" \
            --title "Release $new_version" \
            --notes-file release_notes.md \
            --latest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Update documentation with consolidated Python script
  update-documentation:
    name: Update Version References
    needs: [analyze-changes, create-release]
    if: needs.analyze-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for committing documentation updates
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 1 # Shallow clone sufficient for doc updates
          
      - name: Setup git configuration
        run: |
          git config --local user.name "${{ env.GIT_USER_NAME }}"
          git config --local user.email "${{ env.GIT_USER_EMAIL }}"

      - name: Update version references
        run: |
          new_version="${{ needs.create-release.outputs.new-version }}"
          major_version="${{ needs.create-release.outputs.major-version }}"
          
          echo "🔄 Updating documentation with version: $new_version"
          
          # Consolidated Python script for all version updates
          python3 << 'PYTHON_EOF'
          import re
          import os
          from datetime import datetime
          
          new_version = os.environ['NEW_VERSION']
          major_version = os.environ['MAJOR_VERSION']
          
          print(f"Updating to: {new_version} (major: {major_version})")
          
          # Version reference pattern - more precise to prevent corruption
          version_pattern = r'(broadsage-containers/docker-ops/\.github/workflows/[^@\s]+)@v[0-9]+(?:\.[0-9]+){1,2}(?!\.[0-9])'
          
          files_updated = 0
          
          # Update README.md
          try:
              with open('README.md', 'r') as f:
                  content = f.read()
              
              matches = len(re.findall(version_pattern, content))
              if matches > 0:
                  new_content = re.sub(version_pattern, rf'\1@{new_version}', content)
                  
                  with open('README.md', 'w') as f:
                      f.write(new_content)
                  
                  print(f"✅ README.md: Updated {matches} references")
                  files_updated += 1
              else:
                  print("ℹ️  README.md: No version references found")
                  
          except Exception as e:
              print(f"❌ README.md update failed: {e}")
          
          # Generate VERSION.md
          try:
              version_content = f"""# Version Information
          
          ## Current Release
          
          - **Latest Version**: {new_version}
          - **Major Version**: {major_version}
          - **Release Date**: {datetime.utcnow().strftime('%Y-%m-%d')}
          
          ## Usage Recommendations
          
          ### 🏆 Production (Recommended)
          Use specific semantic versions for production environments:
          
          ```yaml
          uses: broadsage-containers/docker-ops/.github/workflows/{{workflow}}.yml@{new_version}
          ```
          
          ### 🚀 Latest Features
          Use major version tag for latest features (updates automatically):
          
          ```yaml
          uses: broadsage-containers/docker-ops/.github/workflows/{{workflow}}.yml@{major_version}
          ```
          
          ## Available Workflows
          
          - **dependency-review** - Automated dependency vulnerability scanning
          - **quality-gate** - Code quality analysis and linting  
          - **version-docs** - Manual version documentation updates
          - **workflow-release** - Automated workflow versioning and releases
          
          ## Documentation
          
          - [README](README.md) - Getting started guide
          
          ---
          *Generated automatically on {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')} from release {new_version}*
          """
              
              with open('VERSION.md', 'w') as f:
                  f.write(version_content)
              
              print("✅ VERSION.md: Created successfully")
              files_updated += 1
              
          except Exception as e:
              print(f"❌ VERSION.md creation failed: {e}")
          
          print(f"📊 Total files updated: {files_updated}")
          
          # Write update flag for shell script
          with open('update_flag.txt', 'w') as f:
              f.write('true' if files_updated > 0 else 'false')
          PYTHON_EOF
        env:
          NEW_VERSION: ${{ needs.create-release.outputs.new-version }}
          MAJOR_VERSION: ${{ needs.create-release.outputs.major-version }}

      - name: Commit documentation updates
        run: |
          if [[ -f "update_flag.txt" && "$(cat update_flag.txt)" == "true" ]]; then
            echo "📝 Committing documentation updates..."
            git add README.md VERSION.md
            git commit -m "docs: update version references to ${{ needs.create-release.outputs.new-version }} [skip ci]"
            git push
            echo "✅ Documentation updated successfully"
            rm -f update_flag.txt
          else
            echo "ℹ️  No documentation changes to commit"
          fi

  # Notification job for workflow completion
  notify-completion:
    name: Notify Release Complete
    needs: [analyze-changes, create-release, update-documentation]
    if: always() && needs.analyze-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Report release status
        run: |
          release_status="${{ needs.create-release.result }}"
          docs_status="${{ needs.update-documentation.result }}"
          new_version="${{ needs.create-release.outputs.new-version }}"
          workflows="${{ needs.analyze-changes.outputs.changed-workflows }}"
          
          echo "=== 🚀 Docker Ops Release Summary ==="
          echo "Version: $new_version"
          echo "Workflows: $workflows"
          echo "Release: $release_status"
          echo "Documentation: $docs_status"
          
          if [[ "$release_status" == "success" && "$docs_status" == "success" ]]; then
            echo "✅ Release completed successfully!"
            echo "🏷️  New version $new_version is now available"
            echo "📚 Documentation updated automatically"
          else
            echo "❌ Release completed with issues"
            echo "Release status: $release_status"  
            echo "Documentation status: $docs_status"
            exit 1
          fi