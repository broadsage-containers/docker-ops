# SPDX-FileCopyrightText: Copyright (c) 2025 Broadsage Corporation <containers@broadsage.com>
#
# SPDX-License-Identifier: Apache-2.0

---
name: Workflow-Specific Release

on:
  push:
    branches: [main]
    paths:
      - '.github/workflows/*.yml'
      - '!.github/workflows/workflow-release.yml'
      - '!.github/workflows/version-docs.yml'

permissions:
  contents: write
  pull-requests: read

jobs:
  detect-changes:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      changed-workflows: ${{ steps.changes.outputs.workflows }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed workflows
        id: changes
        run: |
          echo "Detecting workflow changes..."
          echo "Commit range: HEAD~1..HEAD"
          
          # Debug: Show all changed files first
          all_changed=$(git diff --name-only HEAD~1 HEAD || true)
          echo "All changed files:"
          echo "$all_changed"
          echo "---"
          
          # Get changed files in the workflows directory (excluding this workflow and version-docs)
          # Use more explicit path matching to ensure we catch all workflow files
          changed_files=$(git diff --name-only HEAD~1 HEAD | grep "^\.github/workflows/.*\.yml$" | grep -v -e "workflow-release.yml" -e "version-docs.yml" || true)
          
          if [[ -z "$changed_files" ]]; then
            echo "No workflow changes detected"
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Changed workflow files:"
          echo "$changed_files"
          echo "---"
          
          # Extract workflow names (without .yml extension)
          workflows=""
          for file in $changed_files; do
            echo "Processing file: $file"
            if [[ $file == *.yml ]]; then
              workflow_name=$(basename "$file" .yml)
              echo "Extracted workflow name: $workflow_name"
              if [[ -n "$workflows" ]]; then
                workflows="$workflows,$workflow_name"
              else
                workflows="$workflow_name"
              fi
            fi
          done
          
          echo "Changed workflows: $workflows"
          echo "workflows=$workflows" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT
  determine-version-bump:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      version-bump: ${{ steps.bump.outputs.bump-type }}
      is-dependency-update: ${{ steps.check-deps.outputs.is-dependency-update }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 100

      - name: Check if dependency update
        id: check-deps
        run: |
          # Check if this is a Dependabot PR or dependency-related commit
          if [[ "${{ github.actor }}" == "dependabot[bot]" ]] || 
             [[ "${{ github.event.head_commit.message }}" =~ ^deps(\(.*\))?: ]]; then
            echo "is-dependency-update=true" >> $GITHUB_OUTPUT
            echo "This is a dependency update"
          else
            echo "is-dependency-update=false" >> $GITHUB_OUTPUT
            echo "This is not a dependency update"
          fi
      - name: Determine version bump type
        id: bump
        run: |
          commit_message="${{ github.event.head_commit.message }}"
          message="$commit_message"
          
          echo "Analyzing commit message: $message"
          
          # Check for breaking changes
          if [[ "$message" =~ BREAKING.CHANGE ]] || 
             [[ "$message" =~ ^[^:]*!: ]] ||
             [[ "$message" =~ ^feat!: ]] ||
             [[ "$message" =~ ^fix!: ]]; then
            echo "bump-type=major" >> $GITHUB_OUTPUT
            echo "Detected BREAKING CHANGE - major version bump"
          # Check for new features
          elif [[ "$message" =~ ^feat(\(.*\))?: ]] ||
               [[ "$message" =~ ^add(\(.*\))?: ]]; then
            echo "bump-type=minor" >> $GITHUB_OUTPUT
            echo "Detected new feature - minor version bump"
          # Everything else is patch (fixes, deps, docs, etc.)
          else
            echo "bump-type=patch" >> $GITHUB_OUTPUT
            echo "Detected patch change - patch version bump"
          fi
  create-release:
    needs: [detect-changes, determine-version-bump]
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      new-version: ${{ steps.version.outputs.new-version }}
      major-version: ${{ steps.version.outputs.major-version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
      - name: Get latest version
        id: latest
        run: |
          # Get the latest semantic version tag (sorted properly)
          latest_tag=$(git tag -l "v*" | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n1 || echo "v0.0.0")
          echo "latest-tag=$latest_tag" >> $GITHUB_OUTPUT
          echo "Current latest tag: $latest_tag"
          
          # Verify this tag exists and is reachable
          if [[ "$latest_tag" != "v0.0.0" ]] && ! git rev-parse --verify "$latest_tag" >/dev/null 2>&1; then
            echo "Warning: Latest tag $latest_tag not found, falling back to v0.0.0"
            latest_tag="v0.0.0"
            echo "latest-tag=$latest_tag" >> $GITHUB_OUTPUT
          fi
      - name: Calculate new version
        id: version
        run: |
          latest_tag="${{ steps.latest.outputs.latest-tag }}"
          bump_type="${{ needs.determine-version-bump.outputs.version-bump }}"
          
          # Remove 'v' prefix and split version
          version=${latest_tag#v}
          IFS='.' read -r major minor patch <<< "$version"
          
          # Default to 0 if parsing fails
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}
          
          echo "Current version: $major.$minor.$patch"
          echo "Bump type: $bump_type"
          
          # Calculate new version based on bump type
          case $bump_type in
            "major")
              new_major=$((major + 1))
              new_minor=0
              new_patch=0
              ;;
            "minor")
              new_major=$major
              new_minor=$((minor + 1))
              new_patch=0
              ;;
            "patch")
              new_major=$major
              new_minor=$minor
              new_patch=$((patch + 1))
              ;;
          esac
          
          new_version="v$new_major.$new_minor.$new_patch"
          major_tag="v$new_major"
          major_version="v$new_major"
          
          echo "new-version=$new_version" >> $GITHUB_OUTPUT
          echo "major-tag=$major_tag" >> $GITHUB_OUTPUT
          echo "major-version=$major_version" >> $GITHUB_OUTPUT
          
          echo "New version will be: $new_version"
          echo "Major tag: $major_tag"
          echo "Major version: $major_version"
      - name: Generate release notes
        id: notes
        run: |
          workflows="${{ needs.detect-changes.outputs.changed-workflows }}"
          version="${{ steps.version.outputs.new-version }}"
          bump_type="${{ needs.determine-version-bump.outputs.version-bump }}"
          is_dep_update="${{ needs.determine-version-bump.outputs.is-dependency-update }}"
          
          # Create clean, minimal release notes
          cat > release_notes.md << EOF
          ## What's Changed
          
          Updated workflows: **$workflows**
          
          EOF
          
          # Get meaningful commits since last release with clickable links
          last_tag="${{ steps.latest.outputs.latest-tag }}"
          
          # Get key changes, filtered and limited
          if [[ "$last_tag" != "v0.0.0" ]]; then
            key_commits=$(git log --oneline --format="format:* [%h](https://github.com/broadsage-containers/docker-ops/commit/%H) %s" "$last_tag"..HEAD -- .github/workflows/ | grep -v -E "chore:|docs:|style:|refactor:|test:" | head -5 || echo "")
          else
            key_commits=$(git log --oneline --format="format:* [%h](https://github.com/broadsage-containers/docker-ops/commit/%H) %s" -- .github/workflows/ | grep -v -E "chore:|docs:|style:|refactor:|test:" | head -5 || echo "")
          fi
          
          if [[ -n "$key_commits" ]]; then
            echo "$key_commits" >> release_notes.md
          else
            echo "* Minor improvements and bug fixes" >> release_notes.md
          fi
          
          cat >> release_notes.md << EOF
          
          ## Usage
          
          \`\`\`yaml
          uses: broadsage-containers/docker-ops/.github/workflows/{workflow}.yml@$version
          \`\`\`
          
          [Full Changelog](https://github.com/broadsage-containers/docker-ops/compare/${{ steps.latest.outputs.latest-tag }}...$version)
          EOF
          
          echo "Generated release notes:"
          cat release_notes.md
      - name: Create and push tags
        run: |
          new_version="${{ steps.version.outputs.new-version }}"
          major_tag="${{ steps.version.outputs.major-tag }}"
          
          echo "Creating semantic version tags: $new_version, $major_tag"
          
          # Semantic versions should be unique - if it exists, something is wrong
          if git rev-parse --verify "$new_version" >/dev/null 2>&1; then
            echo "âŒ ERROR: Semantic version tag $new_version already exists!"
            echo "This indicates an issue with version calculation logic."
            echo "Expected: Each semantic version should be unique"
            git tag -l "v*" | sort -V | tail -5
            exit 1
          fi
          
          # Create the unique semantic version tag
          echo "âœ… Creating semantic version tag: $new_version"
          git tag -a "$new_version" -m "Release $new_version - workflow updates"
          
          # Update major version tag (this one can be moved/updated)
          echo "ğŸ”„ Updating major version tag: $major_tag"
          git tag -f -a "$major_tag" -m "Major version $major_tag (latest: $new_version)"
          
          # Push both tags
          echo "ğŸ“¤ Pushing tags to remote..."
          git push origin "$new_version"
          git push --force origin "$major_tag"
          
          echo "âœ… Successfully created and pushed tags:"
          echo "  ğŸ“Œ Semantic version: $new_version (unique, permanent)"
          echo "  ğŸ”„ Major version: $major_tag (moveable, points to latest)"
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.new-version }}
          name: Release ${{ steps.version.outputs.new-version }}
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-documentation:
    needs: [detect-changes, create-release]
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Ensure we have the latest changes including any tags created in create-release
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Update documentation versions
        run: |
          echo "ğŸ”„ Updating version references in documentation files..."
          
          # Debug: Show what we received from create-release job
          echo "DEBUG: Received version from create-release job:"
          echo "  new-version: '${{ needs.create-release.outputs.new-version }}'"
          echo "  major-version: '${{ needs.create-release.outputs.major-version }}'"
          
          # Get the new version from create-release job
          NEW_VERSION="${{ needs.create-release.outputs.new-version }}"
          echo "Updating docs to version: $NEW_VERSION"
          
          # Validate that we have a version
          if [[ -z "$NEW_VERSION" || "$NEW_VERSION" == "null" ]]; then
            echo "âŒ ERROR: No version received from create-release job!"
            echo "This suggests the create-release job didn't set outputs properly."
            exit 1
          fi
          
          echo "âœ… Version validation passed: $NEW_VERSION"
          
          # Function to update version references in a file
          update_file_versions() {
            local file="$1"
            if [[ ! -f "$file" ]]; then
              return 0
            fi
            
            echo "ğŸ“„ Updating version references in $file..."
            
            # Create backup
            cp "$file" "$file.bak"
            
            # Update specific workflow references
            for workflow in quality-gate security-scorecard dependency-review pr-build-validate pr-build-publish community-management workflow-release version-docs; do
              sed -i "s|broadsage-containers/docker-ops/\.github/workflows/${workflow}\.yml@v[0-9]\+\.[0-9]\+\.[0-9]\+|broadsage-containers/docker-ops/.github/workflows/${workflow}.yml@${NEW_VERSION}|g" "$file"
              sed -i "s|broadsage-containers/docker-ops/\.github/workflows/${workflow}\.yml@v[0-9]\+|broadsage-containers/docker-ops/.github/workflows/${workflow}.yml@${NEW_VERSION}|g" "$file"
            done
            
            # Generic fallback patterns
            sed -i "s|@v[0-9]\+\.[0-9]\+\.[0-9]\+|@${NEW_VERSION}|g" "$file"
            sed -i "s|@v[0-9]\+|@${NEW_VERSION}|g" "$file"
            
            # Check if file was changed
            if ! cmp -s "$file" "$file.bak"; then
              echo "âœ… Updated version references in $file"
              rm -f "$file.bak"
              return 0  # File was updated (success)
            else
              echo "â„¹ï¸  No changes needed in $file"
              rm -f "$file.bak"
              return 1  # File was not updated (failure)
            fi
          }
          
          # Update README.md
          FILES_UPDATED=0
          if update_file_versions "README.md"; then
            ((FILES_UPDATED++))
          fi
          
          # Update other documentation files if they exist
          DOC_FILES=(
            "docs/README.md"
            "docs/USAGE.md"
            "docs/EXAMPLES.md"
            ".github/PULL_REQUEST_TEMPLATE.md"
            "CONTRIBUTING.md"
            "examples/README.md"
          )
          
          for doc_file in "${DOC_FILES[@]}"; do
            if update_file_versions "$doc_file"; then
              ((FILES_UPDATED++))
            fi
          done
          
          # Create/update VERSION.md
          echo "ğŸ“„ Creating VERSION.md documentation..."
          MAJOR_VERSION=$(echo $NEW_VERSION | cut -d. -f1)
          
          cat > VERSION.md << 'EOF'
          # Version Information
          
          ## Current Release
          
          - **Latest Version**: NEW_VERSION_PLACEHOLDER
          - **Major Version**: MAJOR_VERSION_PLACEHOLDER
          - **Release Date**: DATE_PLACEHOLDER
          
          ## Usage Recommendations
          
          ### ğŸ† Production (Recommended)
          Pin to exact versions for maximum stability:
          ```yaml
          uses: broadsage-containers/docker-ops/.github/workflows/quality-gate.yml@NEW_VERSION_PLACEHOLDER
          uses: broadsage-containers/docker-ops/.github/workflows/pr-build-validate.yml@NEW_VERSION_PLACEHOLDER
          uses: broadsage-containers/docker-ops/.github/workflows/pr-build-publish.yml@NEW_VERSION_PLACEHOLDER
          ```
          
          ### âš¡ Development
          Use main branch for latest features (higher risk):
          ```yaml
          uses: broadsage-containers/docker-ops/.github/workflows/quality-gate.yml@main
          uses: broadsage-containers/docker-ops/.github/workflows/pr-build-validate.yml@main
          uses: broadsage-containers/docker-ops/.github/workflows/pr-build-publish.yml@main
          ```
          
          ## Available Versions
          
          ### Recent Releases
          ```
          RECENT_RELEASES_PLACEHOLDER
          ```
          
          ## Resources
          
          - [Releases](https://github.com/broadsage-containers/docker-ops/releases) - Full changelog and release notes
          - [README](README.md) - Getting started guide
          
          ---
          *Generated automatically on DATETIME_PLACEHOLDER from release NEW_VERSION_PLACEHOLDER*
          EOF
          
          # Replace placeholders in VERSION.md
          sed -i "s|NEW_VERSION_PLACEHOLDER|${NEW_VERSION}|g" VERSION.md
          sed -i "s|MAJOR_VERSION_PLACEHOLDER|${MAJOR_VERSION}|g" VERSION.md
          sed -i "s|DATE_PLACEHOLDER|$(date -u '+%Y-%m-%d')|g" VERSION.md
          sed -i "s|DATETIME_PLACEHOLDER|$(date -u '+%Y-%m-%d %H:%M:%S UTC')|g" VERSION.md
          
          # Add recent releases
          RECENT_RELEASES=$(git tag -l --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -10 | tr '\n' '\n')
          sed -i "s|RECENT_RELEASES_PLACEHOLDER|${RECENT_RELEASES}|g" VERSION.md
          
          echo "âœ… VERSION.md created/updated"
          ((FILES_UPDATED++))
          
          # Commit documentation updates
          echo "ğŸ“Š Files updated: $FILES_UPDATED"
          echo "ğŸ” Checking git status:"
          git status --porcelain
          
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "ğŸ“ Committing documentation updates..."
            
            echo "ğŸ“„ Adding files to git:"
            git add README.md VERSION.md
            
            # Add any other updated documentation files
            for doc_file in "${DOC_FILES[@]}"; do
              if [[ -f "$doc_file" ]] && ! git diff --quiet HEAD "$doc_file" 2>/dev/null; then
                echo "ğŸ“„ Adding updated $doc_file"
                git add "$doc_file"
              fi
            done
            
            echo "ğŸ” Final git status before commit:"
            git status --staged
            
            git commit -m "docs: update version references to $NEW_VERSION [skip ci]" -m "Updated $FILES_UPDATED documentation files with latest version references" -m "Generated VERSION.md with release information"
            
            echo "ğŸš€ Pushing documentation updates..."
            if git push; then
              echo "âœ… Documentation updated successfully"
            else
              echo "âŒ Failed to push documentation updates"
              echo "Git status:"
              git status
              echo "Git remote:"
              git remote -v
              exit 1
            fi
          else
            echo "â„¹ï¸  No documentation changes to commit"
          fi

  notify-consumers:
    needs: [detect-changes, create-release, update-documentation]
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Notify about release
        run: |
          workflows="${{ needs.detect-changes.outputs.changed-workflows }}"
          echo "ğŸš€ New release created for workflows: $workflows"
          echo "ğŸ“ Consuming repositories should consider updating their workflow references"
          echo "ğŸ”’ For maximum stability, pin to specific versions"